"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[594],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=r,f=d["".concat(l,".").concat(u)]||d[u]||h[u]||o;return n?a.createElement(f,i(i({ref:t},p),{},{components:n})):a.createElement(f,i({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},245:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:4,id:"resolution",title:"GraphQL Resolution",description:"How data is retrieved and assembled according to the schema and requests"},l="GraphQL Resolution",c={unversionedId:"learn-graphql/resolution",id:"learn-graphql/resolution",title:"GraphQL Resolution",description:"How data is retrieved and assembled according to the schema and requests",source:"@site/docs/learn-graphql/resolution.md",sourceDirName:"learn-graphql",slug:"/learn-graphql/resolution",permalink:"/graphitation/docs/learn-graphql/resolution",editUrl:"https://github.com/microsoft/graphitation/tree/main/website/docs/learn-graphql/resolution.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,id:"resolution",title:"GraphQL Resolution",description:"How data is retrieved and assembled according to the schema and requests"},sidebar:"tutorialSidebar",previous:{title:"Thinking in GraphQL",permalink:"/graphitation/docs/learn-graphql/thinking-in-graphql"},next:{title:"Intro",permalink:"/graphitation/docs/apollo-react-relay-duct-tape/intro"}},p=[{value:"Ask for what you need, get exactly that",id:"ask-for-what-you-need-get-exactly-that",children:[],level:2},{value:"Execution",id:"execution",children:[{value:"Greedy resolution",id:"greedy-resolution",children:[],level:3},{value:"Lazy resolution",id:"lazy-resolution",children:[],level:3},{value:"Models",id:"models",children:[],level:3},{value:"True text",id:"true-text",children:[],level:3}],level:2}],h={toc:p};function d(e){var t=e.components,s=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},h,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"graphql-resolution"},"GraphQL Resolution"),(0,o.kt)("p",null,"The role of an execution engine in GraphQL is to convert between underlying services into GraphQL schema types for use in the front-end. We call this \u201cresolution\u201d."),(0,o.kt)("p",null,"It does so by traversing the schema and resolving the fields requested in the query. The executor follows the structure of the query and passes the data returned by each field resolver to its child field resolvers. The executor ensures that only the fields that are requested by the client are resolved, and that the final result matches the shape of the query."),(0,o.kt)("h2",{id:"ask-for-what-you-need-get-exactly-that"},"Ask for what you need, get exactly that"),(0,o.kt)("p",null,"GraphQL allows clients to specify ",(0,o.kt)("strong",{parentName:"p"},"the exact data")," they need from the service. Unlike traditional RESTful APIs, where clients have to make multiple requests or receive more data than they need, GraphQL lets clients define the structure of the data they want and get ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"only")," that data")," in a single request. This makes GraphQL APIs more efficient, flexible, and scalable."),(0,o.kt)("p",null,"One of the key features of GraphQL is that every field in a GraphQL schema has a corresponding field resolver function that is responsible for fetching and/or transforming the data for that field. Field resolvers can be defined on any type in the schema, not just the root types."),(0,o.kt)("p",null,"By using field resolvers, the GraphQL executor can achieve a high level of performance and flexibility. Clients can get exactly what they need from the service, and the service can optimize their data fetching and processing based on the client's request. This way, GraphQL enables a powerful and elegant way of building APIs that meet the needs of complex data-driven applications."),(0,o.kt)("h2",{id:"execution"},"Execution"),(0,o.kt)("p",null,"To resolve the data of the GraphQL query, we need to define how each field in the schema is fetched from the data source. There are different ways to do this, depending on how we structure our code and how we optimize our performance. In this section, we will explore three examples of how to resolve the data of the query, starting with a naive version that just returns the full response from the root-field, to one that has explicit field resolvers for each field, and finally one that has proper models to represent the underlying data."),(0,o.kt)("p",null,"Let's consider the conversation list UI once more:"),(0,o.kt)("table",null,(0,o.kt)("tr",null,(0,o.kt)("th",null,"Conversation list"),(0,o.kt)("th",null,"Schema"),(0,o.kt)("th",null,"Query")),(0,o.kt)("tr",null,(0,o.kt)("td",null,(0,o.kt)("img",{src:n(9375).Z,border:"1"})),(0,o.kt)("td",null,(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  conversations: [Conversation]\n}\n\ntype Conversation {\n  title: String\n  lastMessage: String\n  participants: [Person]\n}\n\ntype Person {\n  avatarURL: String\n}\n"))),(0,o.kt)("td",null,(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"query {\n  conversations {\n    participants {\n      avatarUrl\n    }\n    title\n    lastMessage\n    receivedAt\n  }\n}\n"))))),(0,o.kt)("h3",{id:"greedy-resolution"},"Greedy resolution"),(0,o.kt)("p",null,"The first example is the simplest one, where we just return the full response from the root-field. This means that we have a single resolver function for the ",(0,o.kt)("inlineCode",{parentName:"p"},"conversations")," field in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Query")," type, and it returns an array of objects that match the shape of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Conversation")," type. We don't need to define any other resolver functions for the nested fields, because GraphQL will ",(0,o.kt)("a",{parentName:"p",href:"#a-note-on-the-default-field-resolver"},"by default")," use the property values of the objects as the field values."),(0,o.kt)("p",null,"For example, if we have a data source that looks like this:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"TODO: Update to reflect screenshot!")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const conversations = [\n  {\n    title: "GraphQL Basics",\n    lastMessage: "Thanks for sharing!",\n    participants: [\n      {\n        avatarURL: "https://example.com/anna.jpg",\n      },\n      {\n        avatarURL: "https://example.com/bob.jpg",\n      },\n    ],\n    receivedAt: "10:29 AM",\n  },\n  {\n    title: "GraphQL Advanced",\n    lastMessage: "That\'s very interesting!",\n    participants: [\n      {\n        avatarURL: "https://example.com/carl.jpg",\n      },\n      {\n        avatarURL: "https://example.com/dana.jpg",\n      },\n    ],\n    receivedAt: "10:20 AM",\n  },\n];\n')),(0,o.kt)("p",null,"Then our resolver function for the conversations field can simply return this array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const resolvers = {\n  Query: {\n    conversations: () => conversations,\n  },\n};\n")),(0,o.kt)("p",null,"This approach is easy to implement, and while it works for trivial queries and data sources, it has some drawbacks. For instance, it can lead to inefficient resource usage and performance issues, because it always returns the full objects for each conversation and person, even if we only request some fields. If we only want to get the ",(0,o.kt)("inlineCode",{parentName:"p"},"title")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"lastMessage")," fields of each conversation, we still get the participants array with ",(0,o.kt)("em",{parentName:"p"},"all")," their ",(0,o.kt)("inlineCode",{parentName:"p"},"avatarURLs"),". This may seem innocuous in this contrived example, but imagine more complex data sources that require expensive logic to fullfil the participants data, and it can quickly add up."),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("h4",{parentName:"div",id:"a-note-on-the-default-field-resolver"},"A note on the default field resolver"),(0,o.kt)("p",{parentName:"div"},"The default field resolver is a function that GraphQL uses to resolve the value of a field when no explicit resolver is provided. It works by looking up the property with the same name as the field on the parent object, or calling it as a function if it is one. For example, if we have a field called ",(0,o.kt)("inlineCode",{parentName:"p"},"title")," on a type called ",(0,o.kt)("inlineCode",{parentName:"p"},"Conversation"),", and no resolver for it, the default field resolver will try to return ",(0,o.kt)("inlineCode",{parentName:"p"},"conversation.title")," or call ",(0,o.kt)("inlineCode",{parentName:"p"},"conversation.title()")," if it exists."),(0,o.kt)("p",{parentName:"div"},"The following set of resolvers has the same result as the above, but ",(0,o.kt)("em",{parentName:"p"},"without")," relying on the default field resolver:"),(0,o.kt)("pre",{parentName:"div"},(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const resolvers = {\n  Query: {\n    conversations: () => conversations,\n  },\n  Conversation: {\n    title: (conversation) => conversation.title,\n    lastMessage: (conversation) => conversation.lastMessage,\n    participants: (conversation) => conversation.participants,\n    receivedAt: (conversation) => conversation.receivedAt,\n  },\n  Participant: {\n    avatarURL: (person) => person.avatarURL,\n  },\n};\n")))),(0,o.kt)("h3",{id:"lazy-resolution"},"Lazy resolution"),(0,o.kt)("p",null,"The second example is more flexible and efficient than the first one, where we can have explicit field resolvers for each field in the schema. These field resolver functions allow us to define how to derive the field's value from the data source."),(0,o.kt)("p",null,"For example, if the ",(0,o.kt)("inlineCode",{parentName:"p"},"receivedAt")," value would not already be formatted in the data source, we can define a resolver function for this field that calculates its human-readable value from the raw format."),(0,o.kt)("p",null,"Here is how our resolver functions could look like in this approach:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const resolvers = {\n  Query: {\n    conversations: () => getConversations(),\n  },\n  Conversation: {\n    title: (conversation) => conversation.title,\n    lastMessage: (conversation) => conversation.lastMessage,\n    participants: (conversation) => conversation.participants,\n    receivedAt: (conversation) => {\n      // Transform the `conversation.receivedAt` value to HH:MM AM/PM\n      const date = new Date(conversation.receivedAt);\n      return date.toLocaleTimeString("en-US", {\n        hour: "numeric",\n        hour12: true,\n        minute: "numeric",\n      });\n    },\n  },\n  Person: {\n    avatarURL: (person) => person.avatarURL,\n  },\n};\n')),(0,o.kt)("p",null,"In this case, when we query for conversations, GraphQL will:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Execute the resolver function for the ",(0,o.kt)("inlineCode",{parentName:"li"},"Query.conversations")," field, which returns an array of conversation objects."),(0,o.kt)("li",{parentName:"ol"},"Then, for each conversation object in the array, GraphQL will execute the resolver function for the ",(0,o.kt)("inlineCode",{parentName:"li"},"Conversation.title"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Conversation.lastMessage"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Conversation.participants"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"Conversation.formattedReceivedAt")," fields. The ",(0,o.kt)("inlineCode",{parentName:"li"},"Conversation.participants")," field returns an array of participant objects."),(0,o.kt)("li",{parentName:"ol"},"And finally, for each participant object in the array, GraphQL will execute the resolver function for the ",(0,o.kt)("inlineCode",{parentName:"li"},"Participant.avatarURL")," field.")),(0,o.kt)("p",null,"We can also use this approach to optimize our performance by ",(0,o.kt)("em",{parentName:"p"},"only")," fetching or returning the data that we need for each field. For example, if we only want to get the ",(0,o.kt)("inlineCode",{parentName:"p"},"title"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"lastMessage"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"formattedReceivedAt")," fields of each conversation, we can avoid fetching or returning the participants array with all their ",(0,o.kt)("inlineCode",{parentName:"p"},"avatarURL"),"s."),(0,o.kt)("p",null,"Another benefit of using explicit field resolvers is that they can apply to any field that returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"Conversation")," type, not just the top-level query. This means that you can reuse the same logic and transformations for different queries that involve conversations. For instance, if you have a ",(0,o.kt)("inlineCode",{parentName:"p"},"Person")," type that has a ",(0,o.kt)("inlineCode",{parentName:"p"},"conversations")," field that returns all the conversations that a user participates in, you can use the same field resolvers as you would use for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Query.conversations")," result. This way, you can avoid inconsistency in your API's results, while staying flexible in the queries it can execute."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const resolvers = {\n  Participant: {\n    conversations: (person) => getConversationsForPersonById(person.id),\n  },\n};\n")),(0,o.kt)("h3",{id:"models"},"Models"),(0,o.kt)("p",null,"TODO: Only fetch participants when necessary, and as another model."),(0,o.kt)("h3",{id:"true-text"},"True text"),(0,o.kt)("p",null,"The object type fields along the selection path may return ",(0,o.kt)("em",{parentName:"p"},"any")," type of data that the child field resolvers might need to perform their work\u2014this data does not in any way need to resemble the public type that is reflected in the GraphQL schema. We call this data the resolver model, and is typically represented by JSON data from back-end services or all the way up to a full-fledged model class."),(0,o.kt)("p",null,"Finallly, work to transform data from the resolver models to the response can move to the leaf fields as much as possible\u2014which are those fields that return scalar types."))}d.isMDXComponent=!0},9375:function(e,t,n){t.Z=n.p+"assets/images/SmallChatList-48df39d6d39f34b20876ae5f9e68c64a.png"}}]);